<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dopplereffekt-Simulation - Luis Marshall</title>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <!-- PDF-Export -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <style>
    :root { --fg:#111; --bg:#fff; --muted:#777; }
    body { font:16px/1.4 system-ui, Segoe UI, Roboto, Arial, sans-serif; color:var(--fg); background:#fff; margin:0; }
    header { padding:16px 20px; border-bottom:1px solid #eee; }
    main { padding:16px 20px; max-width:1200px; margin:0 auto; }
    h1 { font-size:20px; margin:0 0 6px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .card { border:1px solid #eee; border-radius:12px; padding:12px 14px; flex:1 1 320px; }
    label { font-size:13px; color:var(--muted); display:block; margin-bottom:4px; }
    input[type="range"] { width:100%; }
    input, select, button { padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    select, input[type="number"] { width:100%; }
    .inline { display:flex; gap:10px; }
    .inline > div { flex:1; }
    .plots { display:grid; grid-template-columns:1fr; gap:16px; }
    #g1, #g2 { width:100%; height:380px; }
    #g3 { width:100%; height:340px; }
    .muted { color:#666; }
    .hint { font-size:12px; color:#555; }
    .pill { display:inline-block; background:#f3f7ff; color:#284a9f; padding:2px 8px; border-radius:999px; font-size:12px; }
    .btnrow { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .btnrow button { cursor:pointer; background:#f7f7f7; }
    .info { font-size:12px; color:#333; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; margin-top:8px; }
    .section-title { font-weight:600; margin-top:10px; }
    details { border:1px dashed #e5e7eb; border-radius:8px; padding:8px 10px; background:#fcfcff; }
    details > summary { cursor:pointer; font-weight:600; color:#334155; margin:-8px -10px 8px; padding:8px 10px; }
    .note { font-size:12px; color:#555; margin-bottom:8px; }
    .disabled-note { font-size:12px; color:#999; }
    .tiny { font-size:11px; color:#555; margin-top:4px; }
  </style>
</head>
<body>
<header>
  <h1>Dopplereffekt-Simulation - Luis Marshall <span class="pill">client-side</span></h1>
  <div class="muted">Interaktive Rot/Blauverschiebung von Spektrallinien (Kepler-RV möglich)</div>
</header>

<main>
  <div class="row">
    <!-- Linkes Panel -->
    <div class="card" style="max-width:460px">
      <label for="file">Linientabelle (.tab, whitespace-getrennt: Name λ[nm] Amp)</label>
      <input id="file" type="file" accept=".tab,.txt" />
      <div class="hint">Wenn leer, werden Balmer-Defaults verwendet.</div>
      <hr />

      <div class="section-title">Aktueller Doppler</div>
      <div class="inline">
        <div>
          <label for="v">v [m/s] (Live)</label>
          <input id="v" type="range" min="-1000" max="1000" step="1" value="0" />
          <div class="muted"><span id="vLabel">0</span> m/s</div>
        </div>
        <div>
          <label for="vmax">v<sub>max</sub> [m/s] (Skalierung)</label>
          <input id="vmax" type="number" value="1000" step="50" />
          <div class="tiny"><button id="demoRel" type="button">Demo: v = 0.05 c setzen</button></div>
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="widthMode">Linienbreite</label>
          <select id="widthMode">
            <option value="R" selected>Auflösung R (FWHM≈λ/R)</option>
            <option value="FWHM">FWHM [nm] (konstant)</option>
          </select>
        </div>
        <div id="wrapR">
          <label for="R">Wert</label>
          <!-- Default R = 20000 -->
          <input id="R" type="number" value="20000" min="1000" step="1000" />
        </div>
        <div id="wrapFWHM" style="display:none">
          <label for="FWHM">Wert</label>
          <input id="FWHM" type="number" value="0.01" min="0.0001" step="0.0001" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="xmin">x<sub>min</sub> [nm]</label>
          <input id="xmin" type="number" value="300" step="1" />
        </div>
        <div>
          <label for="xmax">x<sub>max</sub> [nm]</label>
          <input id="xmax" type="number" value="800" step="1" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="zoom">Zoom-Zentrum [nm]</label>
          <input id="zoom" type="number" value="656.279" step="0.001" />
        </div>
        <div>
          <label for="dz">±Zoom [nm]</label>
          <input id="dz" type="number" value="0.05" step="0.01" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="presetLine">Zoom auf Linie</label>
          <select id="presetLine"></select>
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="centerZoom">Auf Linie zentrieren</button>
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="colorBy">Farbe (unterer Plot)</label>
          <select id="colorBy">
            <option value="velocity">nach Geschwindigkeit (blau/rot/schwarz)</option>
            <option value="fixed">fix (schwarz)</option>
          </select>
        </div>
        <div>
          <label for="prec">Punkte (Performance)</label>
          <input id="prec" type="number" value="200000" min="20000" step="20000" />
        </div>
      </div>

      <div class="section-title">Orbit-Modus</div>
      <div class="inline">
        <div>
          <label for="orbitMode">v(t) Modell</label>
          <select id="orbitMode">
            <option value="off" selected>Aus (manuell über Slider)</option>
            <option value="sin">Sinus (einfach)</option>
            <option value="kepler">Kepler (Exzentrizität)</option>
          </select>
        </div>
        <div>
          <label for="T_days">Periode P [Tage]</label>
          <input id="T_days" type="number" value="10" step="0.1" min="0.01" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="A_sin">Sinus: Amplitude A [m/s]</label>
          <input id="A_sin" type="number" value="500" step="10" />
        </div>
        <div>
          <label for="v0">Systemgeschwindigkeit V<sub>sys</sub> [m/s]</label>
          <input id="v0" type="number" value="0" step="1" />
        </div>
        <div>
          <label for="phi0">Sinus: Phase φ₀ [rad]</label>
          <input id="phi0" type="number" value="0" step="0.1" />
        </div>
      </div>

      <div class="section-title">Kepler-Parameter (Standard)</div>
      <div class="inline">
        <div>
          <label for="Mstar">M<sub>⋆</sub> [M☉]</label>
          <input id="Mstar" type="number" value="1.0" step="0.01" min="0.01" />
        </div>
        <div>
          <label for="Mpl">m<sub>p</sub> [M<sub>Jup</sub>]</label>
          <input id="Mpl" type="number" value="1.0" step="0.01" min="0.0" />
        </div>
        <div>
          <label for="inc">Inklination i [°]</label>
          <input id="inc" type="number" value="90" step="0.1" min="0" max="180" />
        </div>
      </div>
      <div class="inline" style="margin-top:8px">
        <div>
          <label for="ecc">Exzentrizität e</label>
          <input id="ecc" type="number" value="0.2" step="0.01" min="0" max="0.99" />
        </div>
      </div>

      <!-- Erweitert -->
      <details id="advBox" style="margin-top:8px">
        <summary>Erweitert: Argument des Periastrons ω &amp; Mittelanomalie M₀</summary>
        <div class="note">
          ω beeinflusst die Form der RV-Kurve nur bei <b>e &gt; 0</b>. Für <b>e = 0</b> ist ω beliebig (automatisch deaktiviert).
          M₀ setzt die Orbitalphase zum Startzeitpunkt (immer sinnvoll).
        </div>
        <div class="inline">
          <div>
            <label for="omega">Argument d. Periastron ω [°] <span id="omegaNote" class="disabled-note"></span></label>
            <input id="omega" type="number" value="0" step="1" />
          </div>
          <div>
            <label for="M0">Mittelanomalie M₀ @ t=0 [rad]</label>
            <input id="M0" type="number" value="0" step="0.1" />
          </div>
        </div>
      </details>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="relativistic">Doppler-Modell</label>
          <select id="relativistic">
            <option value="classic" selected>klassisch (λ′ = λ·(1+v/c))</option>
            <option value="rel">relativistisch (λ′ = λ·√((1+β)/(1−β)))</option>
          </select>
          <div class="tiny" id="relNote">Tipp: Für sichtbare Unterschiede v ≳ 0.01 c verwenden (siehe Demo).</div>
        </div>
        <div>
          <label for="timeUnit">Zeitachse</label>
          <select id="timeUnit">
            <option value="s" selected>Sekunden</option>
            <option value="min">Minuten</option>
            <option value="h">Stunden</option>
            <option value="d">Tage</option>
            <option value="y">Jahre</option>
          </select>
        </div>
      </div>

      <div class="btnrow">
        <button id="play">Play</button>
        <button id="png1">PNG Gesamt</button>
        <button id="png2">PNG Zoom</button>
        <button id="pngAll">PNG alle Plots</button>
        <button id="pdfReport">PDF-Report</button>
        <button id="share">Link kopieren</button>
      </div>

      <div class="info" id="infobox">
        z = 0.000000 · Δλ = 0.000 pm · Δν = 0.000 GHz<br>
        <span id="relDiff" class="muted">Relativistik-Effekt @ Zoom: Δλ(rel−klass) = 0.000 pm (0.0 ppm)</span>
      </div>
      <hr />
      <div class="muted" id="meta">Datei: – | Linien: –</div>
    </div>

    <!-- Rechtes Panel (Plots) -->
    <div class="card" style="flex:2 1 680px">
      <div class="plots">
        <div id="g1"></div>
        <div id="g2"></div>
        <div id="g3"></div>
      </div>
    </div>
  </div> <!-- Ende .row -->

  <!-- Bild unten, volle Breite (lokale Kopie) -->
  <figure style="margin-top:16px; max-width:1200px; margin-left:auto; margin-right:auto;">
    <img
      src="BahnelementeEllipse.svg"
      alt="Bahnelemente einer elliptischen Bahn: a, e, i, omega, Omega, nu"
      loading="lazy"
      style="max-width:100%; height:auto; border:1px solid #eee; border-radius:8px; background:#fff"
    >
    <figcaption style="font-size:12px; color:#555; margin-top:6px">
      Bahnelemente einer elliptischen Bahn. Quelle:
      <a href="https://commons.wikimedia.org/wiki/User:Modalanalytiker" target="_blank" rel="noopener">Modalanalytiker</a> – Eigenes Werk,
      <a href="https://creativecommons.org/licenses/by-sa/3.0" target="_blank" rel="noopener">CC BY-SA 3.0</a>,
      <a href="https://commons.wikimedia.org/w/index.php?curid=33729773" target="_blank" rel="noopener">Link</a>.
    </figcaption>
  </figure>
</main>

<footer>
  <div class="hint">Hinweis: Läuft vollständig im Browser. Du kannst die Seite offline speichern oder via GitHub Pages hosten.</div>
</footer>

<script>
"use strict";

// --- Konstanten ---
const C = 299792458.0;
const G = 6.67430e-11;
const M_SUN  = 1.98847e30;
const M_JUP  = 1.89813e27;
const DAY    = 86400.0;
const YEAR   = 365.25*DAY;
const NM     = 1e-9;

// Standard-Balmerlinien
let lines = [
  ["Hα", 656.2790, 0.50],
  ["Hβ", 486.1350, 0.50],
  ["Hγ", 434.0472, 0.50],
  ["Hδ", 410.1734, 0.50],
  ["Hε", 397.0075, 0.50],
  ["Hζ", 388.9064, 0.50],
  ["Hη", 383.5397, 0.50],
  ["Hθ", 379.7909, 0.50]
];

// --- UI ---
const elFile   = document.getElementById('file');
const elV      = document.getElementById('v');
const elVLabel = document.getElementById('vLabel');
const elVmax   = document.getElementById('vmax');
const elR      = document.getElementById('R');
const elFWHM   = document.getElementById('FWHM');
const elMode   = document.getElementById('widthMode');
const elWrapR  = document.getElementById('wrapR');
const elWrapF  = document.getElementById('wrapFWHM');
const elXmin   = document.getElementById('xmin');
const elXmax   = document.getElementById('xmax');
const elZoom   = document.getElementById('zoom');
const elDz     = document.getElementById('dz');
const elColorBy= document.getElementById('colorBy');
const elPrec   = document.getElementById('prec');
const elMeta   = document.getElementById('meta');
const elInfo   = document.getElementById('infobox');
const elPreset = document.getElementById('presetLine');
const elRelDiff= document.getElementById('relDiff');

const elOrbitMode = document.getElementById('orbitMode');
const elT_days = document.getElementById('T_days');
const elA_sin  = document.getElementById('A_sin');
const elV0     = document.getElementById('v0');
const elPhi0   = document.getElementById('phi0');

const elMstar = document.getElementById('Mstar');
const elMpl   = document.getElementById('Mpl');
const elInc   = document.getElementById('inc');
const elEcc   = document.getElementById('ecc');
const elOmega = document.getElementById('omega');
const elM0    = document.getElementById('M0');
const elOmegaNote = document.getElementById('omegaNote');

const elRel = document.getElementById('relativistic');
const elTimeUnit = document.getElementById('timeUnit');
const elDemoRel = document.getElementById('demoRel');

// Datenpuffer
let x=[], y=[], xZoom=[], yZoom=[];
let currentFileLabel = "–";

// Animation
let timer=null, dir=1, t=0, dt=0.03;

// --- Utils ---
function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }
function greekify(name){
  const s=String(name).trim();
  const map=[
    [/h[-\s_]*alpha/gi,"Hα"],[/h[-\s_]*beta/gi,"Hβ"],[/h[-\s_]*gamma/gi,"Hγ"],[/h[-\s_]*delta/gi,"Hδ"],
    [/h[-\s_]*eps(il(on)?)?/gi,"Hε"],[/h[-\s_]*zeta/gi,"Hζ"],[/h[-\s_]*eta/gi,"Hη"],[/h[-\s_]*theta/gi,"Hθ"]
  ];
  let out=s; for(const [re,r] of map) out=out.replace(re,r); return out;
}
function wavelengthToRGB(l){
  let r=0,g=0,b=0;
  if(l<380||l>780) return 'rgb(128,128,128)';
  if(l<440){let t=(l-380)/60; r=-(t)+1; g=0; b=1;}
  else if(l<490){let t=(l-440)/50; r=0; g=t; b=1;}
  else if(l<510){let t=(l-490)/20; r=0; g=1; b=1-t;}
  else if(l<580){let t=(l-510)/70; r=t; g=1; b=0;}
  else if(l<645){let t=(l-580)/65; r=1; g=1-t; b=0;}
  else {r=1; g=0; b=0;}
  if(l<420){let f=0.3+0.7*(l-380)/40; r*=f; g*=f; b*=f;}
  if(l>700){let f=0.3+0.7*(780-l)/80; r*=f; g*=f; b*=f;}
  return `rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`;
}
function gauss(x,A,x0,s){ const out=new Float64Array(x.length),inv=1/(2*s*s);
  for(let i=0;i<x.length;i++){const d=x[i]-x0; out[i]=A*Math.exp(-d*d*inv);} return out; }
function buildAxis(xmin,xmax,npts){ const arr=new Float64Array(npts),dx=(xmax-xmin)/(npts-1);
  for(let i=0;i<npts;i++) arr[i]=xmin+i*dx; return arr; }
function parseTab(text){
  const lam=[],amp=[],name=[];
  for(const raw of text.split(/\r?\n/)){ const s=raw.trim(); if(!s||/^(\#|\/\/|%)/.test(s)) continue;
    const toks=s.split(/\s+/),floats=[],non=[];
    for(const t of toks){ const v=Number(t.replace(',','.')); if(!Number.isNaN(v)&&/^[\d\.,+-]+$/.test(t)) floats.push(v); else non.push(t); }
    if(floats.length<2) continue;
    lam.push(floats[0]); amp.push(floats[1]); name.push(greekify(non.length?non.join(' '):`line_${lam.length}`));
  }
  if(!lam.length) throw new Error("Keine verwertbaren Zeilen in der .tab gefunden.");
  return {name, lam, amp};
}
function colorForV(v){ return v<0?'blue':(v>0?'red':'black'); }
function fwhmArray(lam_nm,mode,R,FWHM){ return (mode==='FWHM')?lam_nm.map(_=>FWHM):lam_nm.map(l=>l/Math.max(1,R)); }

// Doppler-Modelle
function lambdaShift(l0, v, relMode){
  const beta = v / C;
  if (relMode === 'rel'){
    const f = Math.sqrt((1+beta)/(1-beta));
    return l0 * f;
  }
  return l0 * (1 + beta);
}
function freqShift(nu0, v, relMode){
  const beta = v / C;
  if (relMode === 'rel'){
    const f = Math.sqrt((1-beta)/(1+beta));
    return nu0 * f;
  }
  return nu0 * (1 - beta);
}

// Synthese
function synthSpectrum(x,lam_nm,amp,v_ms,mode,R,FWHM,relMode){
  const lamShiftArr = lam_nm.map(l => lambdaShift(l, v_ms, relMode));
  const fwhm=fwhmArray(lam_nm,mode,R,FWHM);
  const sigma=fwhm.map(f=>f/(2*Math.sqrt(2*Math.log(2))));
  const yAbs=new Float64Array(x.length);
  for(let k=0;k<lam_nm.length;k++){
    const g=gauss(x,amp[k],lamShiftArr[k],Math.max(sigma[k],1e-6));
    for(let i=0;i<x.length;i++) yAbs[i]+=g[i];
  }
  const out=new Float64Array(x.length);
  for(let i=0;i<x.length;i++) out[i]=Math.max(0,Math.min(1.1,1-yAbs[i]));
  return out;
}
function populatePresetMenu(){
  elPreset.innerHTML="";
  [...lines].sort((a,b)=>a[1]-b[1]).forEach(L=>{
    const opt=document.createElement('option'); opt.value=String(L[1]);
    opt.textContent=`${L[0]} — ${L[1].toFixed(3)} nm`; elPreset.appendChild(opt);
  });
  const zc=Number(elZoom.value); let best=0,bestd=Infinity;
  lines.forEach((L,i)=>{const d=Math.abs(L[1]-zc); if(d<bestd){bestd=d; best=i;}});
  elPreset.value=String(lines[best][1]);
}
function decimateForColor(xs,ys,maxSeg=600){
  const n=xs.length; if(n<=maxSeg) return [{x:xs,y:ys}];
  const step=Math.floor(n/maxSeg),arr=[]; for(let i=0;i<n-1;i+=step){
    const j=Math.min(i+step,n-1); arr.push({x:xs.slice(i,j+1),y:ys.slice(i,j+1)});} return arr;
}

// Kepler
function solveE(M,e){
  M = Math.atan2(Math.sin(M), Math.cos(M));
  let E = (e<0.8) ? M : Math.PI;
  for (let k=0;k<50;k++){
    const f = E - e*Math.sin(E) - M;
    const fp= 1 - e*Math.cos(E);
    const dE= -f/fp;
    E += dE;
    if (Math.abs(dE) < 1e-12) break;
  }
  return E;
}
function rv_kepler(t){
  const P = Number(elT_days.value)*DAY;
  const e = Number(elEcc.value);
  const i = Number(elInc.value) * Math.PI/180.0;
  const w = Number(elOmega.value) * Math.PI/180.0;
  const M0= Number(elM0.value);
  const Ms = Number(elMstar.value)*M_SUN;
  const Mp = Number(elMpl.value)*M_JUP;
  const vsys = Number(elV0.value);
  const K = Math.cbrt(2*Math.PI*G / P) * (Mp*Math.sin(i)) / (Math.pow(Ms+Mp, 2/3) * Math.sqrt(1-e*e));
  const n = 2*Math.PI / P;
  const M = M0 + n*t;
  const E = solveE(M, e);
  const fac = Math.sqrt((1+e)/(1-e));
  const nu  = 2*Math.atan( fac * Math.tan(E/2) );
  return K * (Math.cos(nu + w) + e*Math.cos(w)) + vsys;
}

// Orbit-Wrapper
function currentVelocity(){
  const mode = elOrbitMode.value;
  if (mode === 'off') return Number(elV.value);
  const vsys = Number(elV0.value);
  const P = Number(elT_days.value)*DAY;
  if (mode === 'sin'){
    const A = Number(elA_sin.value);
    const phi0 = Number(elPhi0.value);
    return vsys + A*Math.sin(2*Math.PI*t/P + phi0);
  }
  return rv_kepler(t);
}

// Zeitachsen-Skalierung
function timeScale() {
  const u = elTimeUnit.value;
  if (u === 's')   return { f: 1,      label: 'Zeit t [s]' };
  if (u === 'min') return { f: 1/60,   label: 'Zeit t [min]' };
  if (u === 'h')   return { f: 1/3600, label: 'Zeit t [h]' };
  if (u === 'd')   return { f: 1/DAY,  label: 'Zeit t [d]' };
  return { f: 1/YEAR, label: 'Zeit t [yr]' };
}

// ω deaktivieren, falls e=0
function updateOmegaEnable() {
  const e = Number(elEcc.value);
  const disable = (Math.abs(e) < 1e-12);
  elOmega.disabled = disable;
  elOmegaNote.textContent = disable ? ' (bei e=0 irrelevant)' : '';
}

// Relativistik-Anzeige: Differenz rel−klass in pm / ppm
function updateRelNote(v, lam0){
  const lamRel = lambdaShift(lam0, v, 'rel');
  const lamCls = lambdaShift(lam0, v, 'classic');
  const dpm = (lamRel - lamCls) * 1e3;
  const ppm = ((lamRel/lamCls) - 1) * 1e6;
  elRelDiff.textContent = `Relativistik-Effekt @ Zoom: Δλ(rel−klass) = ${dpm>=0?'+':''}${dpm.toFixed(3)} pm (${ppm.toFixed(2)} ppm)`;
}

// --- Update/Draw ---
function update(){
  updateOmegaEnable();

  const vmax=Number(elVmax.value); elV.max=vmax; elV.min=-vmax;

  const v = clamp(currentVelocity(), -vmax, vmax);
  elV.value = v; elVLabel.textContent = v.toFixed(0);

  const mode=elMode.value; const R=Math.max(1000,Number(elR.value));
  const FWHM=Math.max(0.000001,Number(elFWHM.value));
  const xmin=Number(elXmin.value), xmax=Number(elXmax.value);
  let npts=Math.max(20000,Number(elPrec.value)); npts=Math.min(npts,600000);

  const zc=Number(elZoom.value), dz=Number(elDz.value);
  const colorByBottom=elColorBy.value;
  const relMode = elRel.value; // 'classic' | 'rel'

  if (x.length!==npts || x[0]!==xmin || x[x.length-1]!==xmax) x=Array.from(buildAxis(xmin, xmax, npts));

  const lam=lines.map(l=>l[1]), amp=lines.map(l=>l[2]);
  y=Array.from(synthSpectrum(x, lam, amp, v, mode, R, FWHM, relMode));

  const xzMin=zc-dz, xzMax=zc+dz; let ix0=0, ix1=x.length-1;
  while (ix0<x.length && x[ix0]<xzMin) ix0++; ix1=ix0; while (ix1<x.length && x[ix1]<=xzMax) ix1++;
  xZoom=x.slice(ix0, ix1); yZoom=y.slice(ix0, ix1);

  drawSpectra(v, colorByBottom, relMode);
  drawTimeSeries(relMode);

  elMeta.textContent = `Datei: ${currentFileLabel} | Linien: ${lines.length} | ${mode==='R'?'R≈'+R:'FWHM≈'+FWHM+' nm'} | Punkte: ${npts}`;

  const lamObs = lambdaShift(zc, v, relMode);
  const dlam_pm = (lamObs - zc)*1e3;
  const nu0=C/(zc*NM);
  const nuObs = freqShift(nu0, v, relMode);
  const dnu_GHz = (nuObs - nu0)/1e9;
  const beta = v/C;
  elInfo.innerHTML = `z = ${beta.toFixed(6)} · Δλ = ${dlam_pm>=0?'+':''}${dlam_pm.toFixed(3)} pm · Δν = ${dnu_GHz>=0?'+':''}${dnu_GHz.toFixed(3)} GHz<br><span id="relDiff" class="muted"></span>`;
  updateRelNote(v, zc);
}

function buildLineMarkers(v, modeTop, colorByBottom, relMode){
  const shapes=[], ann=[];
  for(const [nm,l0,A] of lines){
    const yTop=1.0, yBot=Math.max(0,1.0-A);
    const restColor=modeTop ? wavelengthToRGB(l0) : '#bfbfbf';
    const lShift = lambdaShift(l0, v, relMode);
    const shiftColor=modeTop ? wavelengthToRGB(lShift) : (colorByBottom==='velocity'?colorForV(v):'#000');
    shapes.push({type:'line',x0:l0,x1:l0,y0:yBot,y1:yTop,line:{color:restColor,width:1,dash:modeTop?'solid':'dot'}});
    ann.push({x:l0,y:yBot,text:`${nm}`,showarrow:false,yanchor:'top',font:{size:10,color:'#555'},bgcolor:'#fff',opacity:.9,bordercolor:'#e6e6e6',borderwidth:1});
    shapes.push({type:'line',x0:lShift,x1:lShift,y0:yBot,y1:yTop,line:{color:shiftColor,width:1.6}});
    ann.push({x:lShift,y:yBot,text:`${nm}\u2032`,showarrow:false,yanchor:'top',font:{size:10,color:shiftColor},bgcolor:'#fff',opacity:.9,bordercolor:'#e6e6e6',borderwidth:1});
  }
  return {shapes, ann};
}
function tracesColorByWavelength(xs,ys){
  return decimateForColor(xs,ys,600).map(seg=>({
    x:seg.x, y:seg.y, mode:'lines',
    line:{width:1.4, color:wavelengthToRGB(seg.x[0])},
    hovertemplate:'λ %{x:.3f} nm<br>Flux %{y:.3f}<extra></extra>', showlegend:false
  }));
}
function drawSpectra(v, colorByBottom, relMode){
  // oben
  const topTraces=tracesColorByWavelength(x,y);
  const {shapes:topShapes, ann:topAnn}=buildLineMarkers(v,true,colorByBottom,relMode);
  const layout1={margin:{l:55,r:15,t:32,b:45},xaxis:{title:'Wellenlänge λ [nm]',range:[x[0],x[x.length-1]]},yaxis:{title:'Flux',range:[0,1.05]},shapes:topShapes,annotations:topAnn,title:{text:'Doppler-Verschiebung – Gesamtspektrum',font:{size:16}}};
  Plotly.react('g1', topTraces, layout1, {displayModeBar:false});

  // unten
  const baseColorBottom=(colorByBottom==='velocity')?colorForV(v):'black';
  const bottomTraces=[{x:xZoom,y:yZoom,mode:'lines',line:{width:1.4,color:baseColorBottom},hovertemplate:'λ %{x:.4f} nm<br>Flux %{y:.3f}<extra></extra>'}];
  const {shapes:botShapes, ann:botAnn}=buildLineMarkers(v,false,colorByBottom,relMode);
  const lamShiftVal = lambdaShift(Number(elZoom.value), Number(elV.value), relMode);
  const dpm=(lamShiftVal-Number(elZoom.value))*1e3;
  const layout2={margin:{l:55,r:15,t:32,b:45},xaxis:{title:'λ [nm] (Zoom)',range:[xZoom[0],xZoom[xZoom.length-1]]},yaxis:{title:'Flux',range:[0,1.05]},shapes:botShapes,annotations:[...botAnn,{x:.98,y:.98,xref:'paper',yref:'paper',text:`Δλ @ ${Number(elZoom.value).toFixed(3)} nm: ${dpm>=0?'+':''}${dpm.toFixed(3)} pm`,showarrow:false,bgcolor:'#fff',bordercolor:'#ddd',borderwidth:1,opacity:.9}],title:{text:`Zoom um ${Number(elZoom.value).toFixed(3)} nm`,font:{size:16}}};
  Plotly.react('g2', bottomTraces, layout2, {displayModeBar:false});
}

function timeScale() {
  const u = elTimeUnit.value;
  if (u === 's')   return { f: 1,      label: 'Zeit t [s]' };
  if (u === 'min') return { f: 1/60,   label: 'Zeit t [min]' };
  if (u === 'h')   return { f: 1/3600, label: 'Zeit t [h]' };
  if (u === 'd')   return { f: 1/DAY,  label: 'Zeit t [d]' };
  return { f: 1/YEAR, label: 'Zeit t [yr]' };
}

function drawTimeSeries(relMode){
  const vmax = Math.max(1, Number(elVmax.value));
  const zc   = Number(elZoom.value);
  const y1min=-vmax, y1max=vmax;

  // Symmetrische Δλ-Skala mit relat./klass. Formel
  const lamPlus = lambdaShift(zc,  vmax, relMode);
  const lamMinus= lambdaShift(zc, -vmax, relMode);
  const dlamMax = Math.max(Math.abs(lamPlus - zc), Math.abs(lamMinus - zc)) * 1e3; // pm
  const y2min=-dlamMax, y2max=dlamMax;

  const P = Math.max(0.01, Number(elT_days.value))*DAY;
  const N = 500;
  const t0 = (isFinite(P) && P>0) ? Math.floor(t/P)*P : 0;
  const tStart = t0 - P, tEnd = t0 + P;

  const ts=new Float64Array(N), vs=new Float64Array(N), dls=new Float64Array(N);
  for(let i=0;i<N;i++){
    ts[i]=tStart + (i/(N-1))*(tEnd - tStart);
    const oldT = t; t = ts[i];
    const v = currentVelocity();
    t = oldT;
    vs[i]=v;
    dls[i]=(lambdaShift(zc, v, relMode)-zc)*1e3;
  }

  const { f, label } = timeScale();
  const xPlot = Array.from(ts, s => s * f);
  const xNow  = t * f;
  const xStart = (tStart) * f, xEnd = (tEnd) * f;

  const traceV  = {x:xPlot, y:Array.from(vs), name:'v(t) [m/s]', mode:'lines', line:{width:1.6}};
  const traceDl = {x:xPlot, y:Array.from(dls), name:'Δλ(t) [pm]', mode:'lines', line:{width:1.2, dash:'dot'}, yaxis:'y2'};

  const layout={ margin:{l:55,r:55,t:32,b:45},
    xaxis:{title:label, range:[xStart,xEnd]},
    yaxis:{title:'v [m/s]', range:[y1min,y1max]},
    yaxis2:{title:'Δλ [pm] @ Zoom', overlaying:'y', side:'right', range:[y2min,y2max]},
    shapes:[{type:'line', x0:xNow, x1:xNow, y0:0, y1:1, xref:'x', yref:'paper', line:{color:'#888', width:1}}],
    title:{text:'Zeitverlauf: v(t) (Kepler/Sinus) und Δλ(t)', font:{size:16}},
    legend:{orientation:'h', x:0, y:1.12}
  };
  Plotly.react('g3', [traceV, traceDl], layout, {displayModeBar:false});
}

// --- Export (PNG & PDF) ---
async function exportAllPNGs(){
  await Plotly.downloadImage('g1',{format:'png',filename:'spectrum_full'});
  await Plotly.downloadImage('g2',{format:'png',filename:'spectrum_zoom'});
  await Plotly.downloadImage('g3',{format:'png',filename:'rv_timeseries'});
}

// ASCII-Labels für PDF (jsPDF Standardfont ist nicht Unicode-fähig)
function asciiLabelMap(k){
  const map = {
    Datei:'Datei', Linien:'Linien', Mode:'Breiten-Modus',
    R:'R', 'FWHM':'FWHM [nm]',
    xmin:'xmin [nm]', xmax:'xmax [nm]', zoom:'Zoom [nm]', dz:'±Zoom [nm]',
    colorBy:'Farbe unten', prec:'Punkte',
    orbitMode:'Orbit', T_days:'P [Tage]', A_sin:'A [m/s]', v0:'Vsys [m/s]', phi0:'phi0 [rad]',
    Mstar:'Mstar [M_sun]', Mpl:'mp [M_Jup]', inc:'i [deg]', ecc:'e', omega:'omega [deg]', M0:'M0 [rad]',
    relativistic:'Doppler', vmax:'vmax [m/s]', timeUnit:'Zeitachse'
  };
  return map[k] || k;
}
function asciiSanitize(s){
  // ersetze problematische Unicode-Zeichen
  return String(s)
    .replaceAll('⋆','star')
    .replaceAll('°','deg')
    .replaceAll('φ','phi')
    .replaceAll('ω','omega')
    .replaceAll('Ω','Omega')
    .replaceAll('ν','nu')
    .replaceAll('λ','lambda')
    .replaceAll('·','.')
    .replaceAll('—','-')
    .replaceAll('–','-')
    .replaceAll('’',"'")
    .replaceAll('“','"').replaceAll('”','"');
}
function collectParams(){
  return {
    Datei: currentFileLabel,
    Linien: lines.length,
    Mode: elMode.value,
    R: elR.value,
    FWHM: elFWHM.value,
    xmin: elXmin.value, xmax: elXmax.value,
    zoom: elZoom.value, dz: elDz.value,
    colorBy: elColorBy.value,
    prec: elPrec.value,
    orbitMode: elOrbitMode.value,
    T_days: elT_days.value, A_sin: elA_sin.value, v0: elV0.value, phi0: elPhi0.value,
    Mstar: elMstar.value, Mpl: elMpl.value, inc: elInc.value, ecc: elEcc.value, omega: elOmega.value, M0: elM0.value,
    relativistic: elRel.value,
    vmax: elVmax.value, timeUnit: elTimeUnit.value
  };
}
function paramsToLines(obj){
  const out=[];
  for (const k of Object.keys(obj)){
    const kk = asciiLabelMap(k);
    const vv = asciiSanitize(obj[k]);
    out.push(`${kk}: ${vv}`);
  }
  return out;
}
async function exportPDF(){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({unit:'pt', format:'a4'}); // 595 x 842 pt
  const margin = 36;
  let y = margin;

  // Titel + Timestamp
  doc.setFont('helvetica','bold'); doc.setFontSize(16);
  doc.text('Doppler / RV Report', margin, y); y += 22;
  doc.setFont('helvetica','normal'); doc.setFontSize(10);
  const ts = new Date().toLocaleString();
  doc.text(asciiSanitize(`Erstellt: ${ts}`), margin, y); y += 16;

  // Parameterliste (ASCII)
  const linesTxt = paramsToLines(collectParams());
  const maxWidth = 595 - 2*margin;
  for (const line of linesTxt){
    const chunks = doc.splitTextToSize(line, maxWidth);
    doc.text(chunks, margin, y);
    y += 14 + (chunks.length-1)*12;
    if (y > 780) { doc.addPage(); y = margin; }
  }

  // Plots in brauchbarer Größe rendern
  const wPlot = 520, hPlot = 280;
  const img1 = await Plotly.toImage('g1', {format:'png', width:wPlot, height:hPlot});
  const img2 = await Plotly.toImage('g2', {format:'png', width:wPlot, height:hPlot});
  const img3 = await Plotly.toImage('g3', {format:'png', width:wPlot, height:hPlot});

  // Neue Seite für Abbildungen
  doc.addPage(); y = margin;
  doc.setFont('helvetica','bold'); doc.setFontSize(12);
  doc.text('Abbildungen', margin, y); y += 10;
  doc.setFont('helvetica','normal');

  // Bild 1
  y += 8; doc.addImage(img1, 'PNG', margin, y, wPlot, hPlot); y += hPlot + 16;
  // Bild 2
  if (y + hPlot > 842 - margin) { doc.addPage(); y = margin; }
  doc.addImage(img2, 'PNG', margin, y, wPlot, hPlot); y += hPlot + 16;
  // Bild 3
  if (y + hPlot > 842 - margin) { doc.addPage(); y = margin; }
  doc.addImage(img3, 'PNG', margin, y, wPlot, hPlot);

  doc.save('doppler_rv_report.pdf');
}

// --- Events ---
elFile.addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f) return; currentFileLabel=f.name;
  const text=await f.text();
  try{ const p=parseTab(text); lines=p.name.map((nm,i)=>[nm,p.lam[i],p.amp[i]]); }
  catch(err){ alert("Fehler beim Einlesen: "+err.message); return; }
  populatePresetMenu(); update();
});

[
  elV, elVmax, elR, elFWHM, elXmin, elXmax, elZoom, elDz, elColorBy, elPrec,
  elOrbitMode, elT_days, elA_sin, elV0, elPhi0, elMstar, elMpl, elInc, elEcc, elOmega, elM0,
  elTimeUnit, elRel
].forEach(el=>el.addEventListener('input', update));

elMode.addEventListener('change', ()=>{
  const m=elMode.value;
  if(m==='R'){ elWrapR.style.display='block'; elWrapF.style.display='none'; }
  else      { elWrapR.style.display='none';  elWrapF.style.display='block'; }
  update();
});

document.getElementById('centerZoom').addEventListener('click', ()=>{ elZoom.value=elPreset.value; update(); });
elPreset.addEventListener('change', ()=>{ elZoom.value=elPreset.value; update(); });

document.getElementById('play').onclick=()=>{
  if(timer){ clearInterval(timer); timer=null; return; }
  timer=setInterval(()=>{
    t += dt;
    if (elOrbitMode.value==='off'){
      const vmax=Number(elVmax.value);
      let v=Number(elV.value)+dir*5;
      if(v> vmax){ v=vmax; dir=-1; }
      if(v<-vmax){ v=-vmax; dir=1; }
      elV.value=v;
    }
    update();
  }, 30);
};

document.getElementById('png1').onclick=()=>Plotly.downloadImage('g1',{format:'png',filename:'spectrum_full'});
document.getElementById('png2').onclick=()=>Plotly.downloadImage('g2',{format:'png',filename:'spectrum_zoom'});
document.getElementById('pngAll').onclick=exportAllPNGs;
document.getElementById('pdfReport').onclick=exportPDF;

document.getElementById('share').onclick=()=>{
  const p=new URLSearchParams({
    v:elV.value, vmax:elVmax.value,
    mode:elMode.value, R:elR.value, FWHM:elFWHM.value,
    xmin:elXmin.value, xmax:elXmax.value, zoom:elZoom.value, dz:elDz.value,
    colorBy:elColorBy.value, prec:elPrec.value,
    orbitMode:elOrbitMode.value, T_days:elT_days.value, A_sin:elA_sin.value, v0:elV0.value, phi0:elPhi0.value,
    Mstar:elMstar.value, Mpl:elMpl.value, inc:elInc.value, ecc:elEcc.value, omega:elOmega.value, M0:elM0.value,
    timeUnit:elTimeUnit.value, relativistic:elRel.value
  });
  const url=`${location.origin}${location.pathname}?${p.toString()}`;
  navigator.clipboard.writeText(url).then(()=>alert('Link kopiert:\n'+url));
};

// Demo: 0.05 c für Sichtbarkeit
elDemoRel.addEventListener('click', ()=>{
  const v_demo = 0.05 * C; // 0.05c
  elVmax.value = Math.round(v_demo);
  elV.min = -Math.round(v_demo);
  elV.max = Math.round(v_demo);
  elV.value = Math.round(v_demo);
  elRel.value = 'rel';
  update();
});

// URL-Parameter einlesen
(function(){
  const p=new URLSearchParams(window.location.search);
  const set=(el,key)=>{ if(p.has(key)) el.value=p.get(key); };
  set(elV,'v'); set(elVmax,'vmax'); set(elMode,'mode'); set(elR,'R'); set(elFWHM,'FWHM');
  set(elXmin,'xmin'); set(elXmax,'xmax'); set(elZoom,'zoom'); set(elDz,'dz'); set(elColorBy,'colorBy'); set(elPrec,'prec');
  set(elOrbitMode,'orbitMode'); set(elT_days,'T_days'); set(elA_sin,'A_sin'); set(elV0,'v0'); set(elPhi0,'phi0');
  set(elMstar,'Mstar'); set(elMpl,'Mpl'); set(elInc,'inc'); set(elEcc,'ecc'); set(elOmega,'omega'); set(elM0,'M0');
  set(elTimeUnit,'timeUnit'); set(elRel,'relativistic');
  if (p.has('mode')) elMode.dispatchEvent(new Event('change'));
})();
populatePresetMenu();
update();
</script>
</body>
</html>
