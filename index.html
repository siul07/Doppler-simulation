<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Doppler-Simulation – Radialgeschwindigkeit - Luis Marshall</title>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    :root { --fg:#111; --bg:#fff; --muted:#777; }
    body { font:16px/1.4 system-ui, Segoe UI, Roboto, Arial, sans-serif; color:var(--fg); background:#fff; margin:0; }
    header { padding:16px 20px; border-bottom:1px solid #eee; }
    main { padding:16px 20px; max-width:1200px; margin:0 auto; }
    h1 { font-size:20px; margin:0 0 6px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .card { border:1px solid #eee; border-radius:12px; padding:12px 14px; flex:1 1 320px; }
    label { font-size:13px; color:var(--muted); display:block; margin-bottom:4px; }
    input[type="range"] { width:100%; }
    input, select, button { padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    select, input[type="number"] { width:100%; }
    .inline { display:flex; gap:10px; }
    .inline > div { flex:1; }
    .plots { display:grid; grid-template-columns:1fr; gap:16px; }
    #g1, #g2 { width:100%; height:380px; }
    #g3 { width:100%; height:340px; }
    .muted { color:#666; }
    .hint { font-size:12px; color:#555; }
    .pill { display:inline-block; background:#f3f7ff; color:#284a9f; padding:2px 8px; border-radius:999px; font-size:12px; }
    .btnrow { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .btnrow button { cursor:pointer; background:#f7f7f7; }
    .info { font-size:12px; color:#333; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; margin-top:8px; }
    .section-title { font-weight:600; margin-top:10px; }
  </style>
</head>
<body>
<header>
  <h1>Dopplereffekt-Simulation (Radialgeschwindigkeit) <span class="pill">client-side</span></h1>
  <div class="muted">Interaktive Rot/Blauverschiebung von Spektrallinien (Kepler-RV möglich)</div>
</header>
<main>
  <div class="row">
    <div class="card" style="max-width:460px">
      <label for="file">Linientabelle (.tab, whitespace-getrennt: Name λ[nm] Amp)</label>
      <input id="file" type="file" accept=".tab,.txt" />
      <div class="hint">Wenn leer, werden Balmer-Defaults verwendet.</div>
      <hr />

      <div class="section-title">Aktueller Doppler</div>
      <div class="inline">
        <div>
          <label for="v">v [m/s] (Live)</label>
          <input id="v" type="range" min="-1000" max="1000" step="1" value="0" />
          <div class="muted"><span id="vLabel">0</span> m/s</div>
        </div>
        <div>
          <label for="vmax">v<sub>max</sub> [m/s] (Skalierung)</label>
          <input id="vmax" type="number" value="1000" step="50" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="widthMode">Linienbreite</label>
          <select id="widthMode">
            <option value="R" selected>Auflösung R (FWHM≈λ/R)</option>
            <option value="FWHM">FWHM [nm] (konstant)</option>
          </select>
        </div>
        <div id="wrapR">
          <label for="R">Wert</label>
          <input id="R" type="number" value="70000" min="1000" step="1000" />
        </div>
        <div id="wrapFWHM" style="display:none">
          <label for="FWHM">Wert</label>
          <input id="FWHM" type="number" value="0.01" min="0.0001" step="0.0001" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="xmin">x<sub>min</sub> [nm]</label>
          <input id="xmin" type="number" value="300" step="1" />
        </div>
        <div>
          <label for="xmax">x<sub>max</sub> [nm]</label>
          <input id="xmax" type="number" value="800" step="1" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="zoom">Zoom-Zentrum [nm]</label>
          <input id="zoom" type="number" value="656.279" step="0.001" />
        </div>
        <div>
          <label for="dz">±Zoom [nm]</label>
          <input id="dz" type="number" value="0.05" step="0.01" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="presetLine">Zoom auf Linie</label>
          <select id="presetLine"></select>
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="centerZoom">Auf Linie zentrieren</button>
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="colorBy">Farbe (unterer Plot)</label>
          <select id="colorBy">
            <option value="velocity">nach Geschwindigkeit (blau/rot/schwarz)</option>
            <option value="fixed">fix (schwarz)</option>
          </select>
        </div>
        <div>
          <label for="prec">Punkte (Performance)</label>
          <input id="prec" type="number" value="200000" min="20000" step="20000" />
        </div>
      </div>

      <div class="section-title">Orbit-Modus</div>
      <div class="inline">
        <div>
          <label for="orbitMode">v(t) Modell</label>
          <select id="orbitMode">
            <option value="off" selected>Aus (manuell über Slider)</option>
            <option value="sin">Sinus (einfach)</option>
            <option value="kepler">Kepler (Exzentrizität)</option>
          </select>
        </div>
        <div>
          <label for="T_days">Periode P [Tage]</label>
          <input id="T_days" type="number" value="10" step="0.1" min="0.01" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div>
          <label for="A_sin">Sinus: Amplitude A [m/s]</label>
          <input id="A_sin" type="number" value="500" step="10" />
        </div>
        <div>
          <label for="v0">Systemgeschwindigkeit V<sub>sys</sub> [m/s]</label>
          <input id="v0" type="number" value="0" step="1" />
        </div>
        <div>
          <label for="phi0">Sinus: Phase φ₀ [rad]</label>
          <input id="phi0" type="number" value="0" step="0.1" />
        </div>
      </div>

      <div class="section-title">Kepler-Parameter</div>
      <div class="inline">
        <div>
          <label for="Mstar">M<sub>⋆</sub> [M☉]</label>
          <input id="Mstar" type="number" value="1.0" step="0.01" min="0.01" />
        </div>
        <div>
          <label for="Mpl">m<sub>p</sub> [M<sub>Jup</sub>]</label>
          <input id="Mpl" type="number" value="1.0" step="0.01" min="0.0" />
        </div>
        <div>
          <label for="inc">Inklination i [°]</label>
          <input id="inc" type="number" value="90" step="0.1" min="0" max="180" />
        </div>
      </div>
      <div class="inline" style="margin-top:8px">
        <div>
          <label for="ecc">Exzentrizität e</label>
          <input id="ecc" type="number" value="0.2" step="0.01" min="0" max="0.99" />
        </div>
        <div>
          <label for="omega">Argument d. Periastron ω [°]</label>
          <input id="omega" type="number" value="0" step="1" />
        </div>
        <div>
          <label for="M0">Mittelanomalie M₀ @ t=0 [rad]</label>
          <input id="M0" type="number" value="0" step="0.1" />
        </div>
      </div>

      <div class="btnrow">
        <button id="play">Play</button>
        <button id="png1">PNG Gesamt</button>
        <button id="png2">PNG Zoom</button>
        <button id="share">Link kopieren</button>
      </div>

      <div class="info" id="infobox">z = 0.000000 • Δλ = 0.000 pm • Δν = 0.000 GHz</div>
      <hr />
      <div class="muted" id="meta">Datei: – | Linien: –</div>
    </div>

    <div class="card" style="flex:2 1 680px">
      <div class="plots">
        <div id="g1"></div>
        <div id="g2"></div>
        <div id="g3"></div>
      </div>
    </div>
  </div>
</main>
<footer>
  <div class="hint">Hinweis: Läuft vollständig im Browser. Du kannst die Seite offline speichern oder via GitHub Pages hosten.</div>
</footer>

<script>
"use strict";

// Physikalische Konstanten
const C = 299792458.0;                      // m/s
const G = 6.67430e-11;                      // SI
const M_SUN  = 1.98847e30;                  // kg
const M_JUP  = 1.89813e27;                  // kg
const DAY    = 86400.0;                     // s
const NM     = 1e-9;

// Standard-Balmerlinien (Name, λ[nm], Amplitude)
let lines = [
  ["Hα", 656.2790, 0.50],
  ["Hβ", 486.1350, 0.50],
  ["Hγ", 434.0472, 0.50],
  ["Hδ", 410.1734, 0.50],
  ["Hε", 397.0075, 0.50],
  ["Hζ", 388.9064, 0.50],
  ["Hη", 383.5397, 0.50],
  ["Hθ", 379.7909, 0.50]
];

// --- UI-Refs ---
const elFile   = document.getElementById('file');
const elV      = document.getElementById('v');
const elVLabel = document.getElementById('vLabel');
const elVmax   = document.getElementById('vmax');
const elR      = document.getElementById('R');
const elFWHM   = document.getElementById('FWHM');
const elMode   = document.getElementById('widthMode');
const elWrapR  = document.getElementById('wrapR');
const elWrapF  = document.getElementById('wrapFWHM');
const elXmin   = document.getElementById('xmin');
const elXmax   = document.getElementById('xmax');
const elZoom   = document.getElementById('zoom');
const elDz     = document.getElementById('dz');
const elColorBy= document.getElementById('colorBy');
const elPrec   = document.getElementById('prec');
const elMeta   = document.getElementById('meta');
const elInfo   = document.getElementById('infobox');
const elPreset = document.getElementById('presetLine');

// Orbit/UI
const elOrbitMode = document.getElementById('orbitMode');
const elT_days = document.getElementById('T_days');
const elA_sin  = document.getElementById('A_sin');
const elV0     = document.getElementById('v0');
const elPhi0   = document.getElementById('phi0');

const elMstar = document.getElementById('Mstar');
const elMpl   = document.getElementById('Mpl');
const elInc   = document.getElementById('inc');
const elEcc   = document.getElementById('ecc');
const elOmega = document.getElementById('omega');
const elM0    = document.getElementById('M0');

// Datenpuffer
let x=[], y=[], xZoom=[], yZoom=[];
let currentFileLabel = "–";

// Zeit-Animation
let timer=null, dir=1;      // dir nur für „off“/Sinus, Kepler nutzt echte Zeit
let t=0;                    // s
const dt=0.03;              // s pro Frame (simuliert ~30ms)

// --- Utils ---
function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }
function greekify(name){
  const s=String(name).trim();
  const map=[
    [/h[-\s_]*alpha/gi,"Hα"],[/h[-\s_]*beta/gi,"Hβ"],[/h[-\s_]*gamma/gi,"Hγ"],[/h[-\s_]*delta/gi,"Hδ"],
    [/h[-\s_]*eps(il(on)?)?/gi,"Hε"],[/h[-\s_]*zeta/gi,"Hζ"],[/h[-\s_]*eta/gi,"Hη"],[/h[-\s_]*theta/gi,"Hθ"]
  ];
  let out=s; for(const [re,r] of map) out=out.replace(re,r); return out;
}
function wavelengthToRGB(l){
  let r=0,g=0,b=0;
  if(l<380||l>780) return 'rgb(128,128,128)';
  if(l<440){let t=(l-380)/60; r=-(t)+1; g=0; b=1;}
  else if(l<490){let t=(l-440)/50; r=0; g=t; b=1;}
  else if(l<510){let t=(l-490)/20; r=0; g=1; b=1-t;}
  else if(l<580){let t=(l-510)/70; r=t; g=1; b=0;}
  else if(l<645){let t=(l-580)/65; r=1; g=1-t; b=0;}
  else {r=1; g=0; b=0;}
  if(l<420){let f=0.3+0.7*(l-380)/40; r*=f; g*=f; b*=f;}
  if(l>700){let f=0.3+0.7*(780-l)/80; r*=f; g*=f; b*=f;}
  return `rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`;
}
function gauss(x,A,x0,s){ const out=new Float64Array(x.length),inv=1/(2*s*s);
  for(let i=0;i<x.length;i++){const d=x[i]-x0; out[i]=A*Math.exp(-d*d*inv);} return out; }
function buildAxis(xmin,xmax,npts){ const arr=new Float64Array(npts),dx=(xmax-xmin)/(npts-1);
  for(let i=0;i<npts;i++) arr[i]=xmin+i*dx; return arr; }
function parseTab(text){
  const lam=[],amp=[],name=[];
  for(const raw of text.split(/\r?\n/)){ const s=raw.trim(); if(!s||/^(\#|\/\/|%)/.test(s)) continue;
    const toks=s.split(/\s+/),floats=[],non=[];
    for(const t of toks){ const v=Number(t.replace(',','.')); if(!Number.isNaN(v)&&/^[\d\.,+-]+$/.test(t)) floats.push(v); else non.push(t); }
    if(floats.length<2) continue;
    lam.push(floats[0]); amp.push(floats[1]); name.push(greekify(non.length?non.join(' '):`line_${lam.length}`));
  }
  if(!lam.length) throw new Error("Keine verwertbaren Zeilen in der .tab gefunden.");
  return {name, lam, amp};
}
function colorForV(v){ return v<0?'blue':(v>0?'red':'black'); }
function fwhmArray(lam_nm,mode,R,FWHM){ return (mode==='FWHM')?lam_nm.map(_=>FWHM):lam_nm.map(l=>l/Math.max(1,R)); }
function synthSpectrum(x,lam_nm,amp,v_ms,mode,R,FWHM){
  const lamShift=lam_nm.map(l=>l*(1+v_ms/C));
  const fwhm=fwhmArray(lam_nm,mode,R,FWHM);
  const sigma=fwhm.map(f=>f/(2*Math.sqrt(2*Math.log(2))));
  const yAbs=new Float64Array(x.length);
  for(let k=0;k<lam_nm.length;k++){ const g=gauss(x,amp[k],lamShift[k],Math.max(sigma[k],1e-6));
    for(let i=0;i<x.length;i++) yAbs[i]+=g[i]; }
  const out=new Float64Array(x.length);
  for(let i=0;i<x.length;i++) out[i]=Math.max(0,Math.min(1.1,1-yAbs[i]));
  return out;
}
function populatePresetMenu(){
  elPreset.innerHTML="";
  [...lines].sort((a,b)=>a[1]-b[1]).forEach(L=>{
    const opt=document.createElement('option'); opt.value=String(L[1]);
    opt.textContent=`${L[0]} — ${L[1].toFixed(3)} nm`; elPreset.appendChild(opt);
  });
  const zc=Number(elZoom.value); let best=0,bestd=Infinity;
  lines.forEach((L,i)=>{const d=Math.abs(L[1]-zc); if(d<bestd){bestd=d; best=i;}});
  elPreset.value=String(lines[best][1]);
}
function decimateForColor(xs,ys,maxSeg=600){
  const n=xs.length; if(n<=maxSeg) return [{x:xs,y:ys}];
  const step=Math.floor(n/maxSeg),arr=[]; for(let i=0;i<n-1;i+=step){
    const j=Math.min(i+step,n-1); arr.push({x:xs.slice(i,j+1),y:ys.slice(i,j+1)});} return arr;
}

// --- Kepler: RV(t) ---
// Kepler-Gleichung: M = E - e sin E (löse nach E)
function solveE(M,e){
  // bring M in [-pi, pi] für bessere Konvergenz
  M = Math.atan2(Math.sin(M), Math.cos(M));
  let E = (e<0.8) ? M : Math.PI; // Startwert
  for (let k=0;k<50;k++){
    const f = E - e*Math.sin(E) - M;
    const fp= 1 - e*Math.cos(E);
    const dE= -f/fp;
    E += dE;
    if (Math.abs(dE) < 1e-12) break;
  }
  return E;
}
function rv_kepler(t){
  const P = Number(elT_days.value)*DAY;          // s
  const e = Number(elEcc.value);
  const i = Number(elInc.value) * Math.PI/180.0; // rad
  const w = Number(elOmega.value) * Math.PI/180.0; // rad
  const M0= Number(elM0.value);                  // rad (bei t=0)
  const Ms = Number(elMstar.value)*M_SUN;        // kg
  const Mp = Number(elMpl.value)*M_JUP;          // kg
  const vsys = Number(elV0.value);               // m/s

  // semi-amplitude K nach (8):
  // K = (2πG/P)^(1/3) * (Mp sin i) / ( (M*+Mp)^(2/3) * sqrt(1-e^2) )
  const K = Math.cbrt(2*Math.PI*G / P) * (Mp*Math.sin(i)) / (Math.pow(Ms+Mp, 2/3) * Math.sqrt(1-e*e));

  const n = 2*Math.PI / P;            // mittlere Bewegung
  const M = M0 + n*t;                 // Mittelanomalie
  const E = solveE(M, e);             // Exzentrische Anomalie
  const fac = Math.sqrt((1+e)/(1-e));
  const nu  = 2*Math.atan( fac * Math.tan(E/2) );   // wahre Anomalie

  // (9) v_r*(ν) = K * (cos(ν + ω) + e cos ω) + V_sys
  const vr = K * (Math.cos(nu + w) + e*Math.cos(w)) + vsys;
  return vr;
}

// Orbit-Wrapper (off/sin/kepler)
function currentVelocity(){
  const mode = elOrbitMode.value;
  if (mode === 'off') return Number(elV.value);

  const vsys = Number(elV0.value);
  const P = Number(elT_days.value)*DAY;
  if (mode === 'sin'){
    const A = Number(elA_sin.value);
    const phi0 = Number(elPhi0.value);
    return vsys + A*Math.sin(2*Math.PI*t/P + phi0);
  }
  // Kepler
  return rv_kepler(t);
}

// --- Update/Draw ---
let needAxis = true; // für initiale Achsensetzung

function update(){
  const vmax=Number(elVmax.value); elV.max=vmax; elV.min=-vmax;

  const v = clamp(currentVelocity(), -vmax, vmax);
  elV.value = v; elVLabel.textContent = v.toFixed(0);

  const mode=elMode.value; const R=Math.max(1000,Number(elR.value));
  const FWHM=Math.max(0.000001,Number(elFWHM.value));
  const xmin=Number(elXmin.value), xmax=Number(elXmax.value);
  let npts=Math.max(20000,Number(elPrec.value)); npts=Math.min(npts,600000);

  const zc=Number(elZoom.value), dz=Number(elDz.value);
  const colorByBottom=elColorBy.value;

  if (x.length!==npts || x[0]!==xmin || x[x.length-1]!==xmax) x=Array.from(buildAxis(xmin, xmax, npts));

  const lam=lines.map(l=>l[1]), amp=lines.map(l=>l[2]);
  y=Array.from(synthSpectrum(x, lam, amp, v, mode, R, FWHM));

  const xzMin=zc-dz, xzMax=zc+dz; let ix0=0, ix1=x.length-1;
  while (ix0<x.length && x[ix0]<xzMin) ix0++; ix1=ix0; while (ix1<x.length && x[ix1]<=xzMax) ix1++;
  xZoom=x.slice(ix0, ix1); yZoom=y.slice(ix0, ix1);

  drawSpectra(v, colorByBottom);
  drawTimeSeries(); // Kurven immer zeichnen

  elMeta.textContent = `Datei: ${currentFileLabel} | Linien: ${lines.length} | ${mode==='R'?'R≈'+R:'FWHM≈'+FWHM+' nm'} | Punkte: ${npts}`;

  const z=v/C, dlam_pm=(zc*(1+v/C)-zc)*1e3, nu0=C/(zc*NM), dnu_GHz=-(nu0*v/C)/1e9;
  elInfo.textContent = `z = ${z.toFixed(6)} • Δλ = ${dlam_pm>=0?'+':''}${dlam_pm.toFixed(3)} pm • Δν = ${dnu_GHz>=0?'+':''}${dnu_GHz.toFixed(3)} GHz`;
}

function buildLineMarkers(v, modeTop, colorByBottom){
  const shapes=[], ann=[];
  for(const [nm,l0,A] of lines){
    const yTop=1.0, yBot=Math.max(0,1.0-A);
    const restColor=modeTop ? wavelengthToRGB(l0) : '#bfbfbf';
    const shiftColor=modeTop ? wavelengthToRGB(l0*(1+v/C)) : (colorByBottom==='velocity'?colorForV(v):'#000');
    shapes.push({type:'line',x0:l0,x1:l0,y0:yBot,y1:yTop,line:{color:restColor,width:1,dash:modeTop?'solid':'dot'}});
    ann.push({x:l0,y:yBot,text:`${nm}`,showarrow:false,yanchor:'top',font:{size:10,color:'#555'},bgcolor:'#fff',opacity:.9,bordercolor:'#e6e6e6',borderwidth:1});
    const ls=l0*(1+v/C);
    shapes.push({type:'line',x0:ls,x1:ls,y0:yBot,y1:yTop,line:{color:shiftColor,width:1.6}});
    ann.push({x:ls,y:yBot,text:`${nm}\u2032`,showarrow:false,yanchor:'top',font:{size:10,color:shiftColor},bgcolor:'#fff',opacity:.9,bordercolor:'#e6e6e6',borderwidth:1});
  }
  return {shapes, ann};
}
function tracesColorByWavelength(xs,ys){
  return decimateForColor(xs,ys,600).map(seg=>({
    x:seg.x, y:seg.y, mode:'lines',
    line:{width:1.4, color:wavelengthToRGB(seg.x[0])},
    hovertemplate:'λ %{x:.3f} nm<br>Flux %{y:.3f}<extra></extra>', showlegend:false
  }));
}
function drawSpectra(v, colorByBottom){
  // oben: Wellenlängenfarbe
  const topTraces=tracesColorByWavelength(x,y);
  const {shapes:topShapes, ann:topAnn}=buildLineMarkers(v,true,colorByBottom);
  const layout1={margin:{l:55,r:15,t:32,b:45},xaxis:{title:'Wellenlänge λ [nm]',range:[x[0],x[x.length-1]]},yaxis:{title:'Flux',range:[0,1.05]},shapes:topShapes,annotations:topAnn,title:{text:'Doppler-Verschiebung – Gesamtspektrum',font:{size:16}}};
  Plotly.react('g1', topTraces, layout1, {displayModeBar:false});

  // unten: velocity/fixed
  const baseColorBottom=(colorByBottom==='velocity')?colorForV(v):'black';
  const bottomTraces=[{x:xZoom,y:yZoom,mode:'lines',line:{width:1.4,color:baseColorBottom},hovertemplate:'λ %{x:.4f} nm<br>Flux %{y:.3f}<extra></extra>'}];
  const {shapes:botShapes, ann:botAnn}=buildLineMarkers(v,false,colorByBottom);
  const lamShift=Number(elZoom.value)*(1+Number(elV.value)/C); const dpm=(lamShift-Number(elZoom.value))*1e3;
  const layout2={margin:{l:55,r:15,t:32,b:45},xaxis:{title:'λ [nm] (Zoom)',range:[xZoom[0],xZoom[xZoom.length-1]]},yaxis:{title:'Flux',range:[0,1.05]},shapes:botShapes,annotations:[...botAnn,{x:.98,y:.98,xref:'paper',yref:'paper',text:`Δλ @ ${Number(elZoom.value).toFixed(3)} nm: ${dpm>=0?'+':''}${dpm.toFixed(3)} pm`,showarrow:false,bgcolor:'#fff',bordercolor:'#ddd',borderwidth:1,opacity:.9}],title:{text:`Zoom um ${Number(elZoom.value).toFixed(3)} nm`,font:{size:16}}};
  Plotly.react('g2', bottomTraces, layout2, {displayModeBar:false});
}

function drawTimeSeries(){
  const vmax = Math.max(1, Number(elVmax.value));
  const zc   = Number(elZoom.value);
  const y1min=-vmax, y1max=vmax;
  const dlamMax = zc * (vmax/C) * 1e3; // pm
  const y2min=-dlamMax, y2max=dlamMax;

  // Zeitfenster: zwei Perioden um t
  const P = Math.max(0.01, Number(elT_days.value))*DAY;
  const N = 500;
  const t0 = (isFinite(P) && P>0) ? Math.floor(t/P)*P : 0;
  const tStart = t0 - P, tEnd = t0 + P;

  const ts=new Float64Array(N), vs=new Float64Array(N), dls=new Float64Array(N);
  for(let i=0;i<N;i++){
    ts[i]=tStart + (i/(N-1))*(tEnd - tStart);
    const oldT = t; t = ts[i];
    const v = currentVelocity();
    t = oldT;
    vs[i]=v;
    dls[i]=(zc*(1+v/C)-zc)*1e3;
  }

  const traceV  = {x:Array.from(ts), y:Array.from(vs), name:'v(t) [m/s]', mode:'lines', line:{width:1.6}};
  const traceDl = {x:Array.from(ts), y:Array.from(dls), name:'Δλ(t) [pm]', mode:'lines', line:{width:1.2, dash:'dot'}, yaxis:'y2'};

  const layout={ margin:{l:55,r:55,t:32,b:45},
    xaxis:{title:'Zeit t [s]', range:[tStart,tEnd]},
    yaxis:{title:'v [m/s]', range:[y1min,y1max]},
    yaxis2:{title:'Δλ [pm] @ Zoom', overlaying:'y', side:'right', range:[y2min,y2max]},
    shapes:[{type:'line', x0:t, x1:t, y0:0, y1:1, xref:'x', yref:'paper', line:{color:'#888', width:1}}],
    title:{text:'Zeitverlauf: v(t) (Kepler/Sinus) und Δλ(t)', font:{size:16}},
    legend:{orientation:'h', x:0, y:1.12}
  };
  Plotly.react('g3', [traceV, traceDl], layout, {displayModeBar:false});
}

// --- Events ---
elFile.addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f) return; currentFileLabel=f.name;
  const text=await f.text();
  try{ const p=parseTab(text); lines=p.name.map((nm,i)=>[nm,p.lam[i],p.amp[i]]); }
  catch(err){ alert("Fehler beim Einlesen: "+err.message); return; }
  populatePresetMenu(); update();
});

[
  elV, elVmax, elR, elFWHM, elXmin, elXmax, elZoom, elDz, elColorBy, elPrec,
  elOrbitMode, elT_days, elA_sin, elV0, elPhi0, elMstar, elMpl, elInc, elEcc, elOmega, elM0
].forEach(el=>el.addEventListener('input', update));

elMode.addEventListener('change', ()=>{
  const m=elMode.value;
  if(m==='R'){ elWrapR.style.display='block'; elWrapF.style.display='none'; }
  else      { elWrapR.style.display='none';  elWrapF.style.display='block'; }
  update();
});

elPreset.addEventListener('change', ()=>{ elZoom.value=elPreset.value; update(); });
document.getElementById('centerZoom').addEventListener('click', ()=>{ elZoom.value=elPreset.value; update(); });

document.getElementById('play').onclick=()=>{
  if(timer){ clearInterval(timer); timer=null; return; }
  timer=setInterval(()=>{
    t += dt; // echte Zeit
    if (elOrbitMode.value==='off'){ // alter Bounceslider
      const vmax=Number(elVmax.value);
      let v=Number(elV.value)+dir*5;
      if(v> vmax){ v=vmax; dir=-1; }
      if(v<-vmax){ v=-vmax; dir=1; }
      elV.value=v;
    }
    update();
  }, 30);
};

document.getElementById('png1').onclick=()=>Plotly.downloadImage('g1',{format:'png',filename:'spectrum_full'});
document.getElementById('png2').onclick=()=>Plotly.downloadImage('g2',{format:'png',filename:'spectrum_zoom'});

document.getElementById('share').onclick=()=>{
  const p=new URLSearchParams({
    v:elV.value, vmax:elVmax.value,
    mode:elMode.value, R:elR.value, FWHM:elFWHM.value,
    xmin:elXmin.value, xmax:elXmax.value, zoom:elZoom.value, dz:elDz.value,
    colorBy:elColorBy.value, prec:elPrec.value,
    orbitMode:elOrbitMode.value, T_days:elT_days.value, A_sin:elA_sin.value, v0:elV0.value, phi0:elPhi0.value,
    Mstar:elMstar.value, Mpl:elMpl.value, inc:elInc.value, ecc:elEcc.value, omega:elOmega.value, M0:elM0.value
  });
  const url=`${location.origin}${location.pathname}?${p.toString()}`;
  navigator.clipboard.writeText(url).then(()=>alert('Link kopiert:\n'+url));
};

// URL-Parameter einlesen (optional)
(function(){
  const p=new URLSearchParams(window.location.search);
  const set=(el,key)=>{ if(p.has(key)) el.value=p.get(key); };
  set(elV,'v'); set(elVmax,'vmax'); set(elMode,'mode'); set(elR,'R'); set(elFWHM,'FWHM');
  set(elXmin,'xmin'); set(elXmax,'xmax'); set(elZoom,'zoom'); set(elDz,'dz'); set(elColorBy,'colorBy'); set(elPrec,'prec');
  set(elOrbitMode,'orbitMode'); set(elT_days,'T_days'); set(elA_sin,'A_sin'); set(elV0,'v0'); set(elPhi0,'phi0');
  set(elMstar,'Mstar'); set(elMpl,'Mpl'); set(elInc,'inc'); set(elEcc,'ecc'); set(elOmega,'omega'); set(elM0,'M0');
  if (p.has('mode')) elMode.dispatchEvent(new Event('change'));
})();

// Init
populatePresetMenu();
update();
</script>
</body>
</html>

